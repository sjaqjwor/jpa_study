### 엔티티매니저 팩토리

- Db 설정파일(persistenc.xml)을 가지고 어플리케이션에 보통 한개가 생성되며 , 이를 통해 엔티티매니저를 생성한다
- 여러 스레드가 접근해도 안전하다

### 엔티티매니저

- 엔티티를 관리하는 역할
- 스레드간 공유 하면 안된다
  - 여러스레드가 raceCondition발생 하며  , 스레드마다 flush , 조회를 하기 때문에 올바른 데이터를 활용할 수 없다.
- 데이터 베이스 연결이 필요한 시점까지 커넥션 연걸x

- 영속성 컨텍스트에 접근하는 역할
- 앤티티매니저는 트랜잭션이 커밋되는 순간 flush가 된다.

### 영속성 컨텍스트

- 엔티티를 영구 저장하는 환경
- 영속성 컨텍스트는 내부적으로 앤티티 식별자 값으로 앤티티를 구분
  - 만약에 엔티티식별자가 같아도 내부적으로 객체타입 정보도 활용한다
- 이점
  - 1차캐시
    - 쉽게 말하면 영속 컨텍스트 내부에 엔티티를 보관 하는 장소
    - 솔직히 엄청난 이점 누리기 어렵다, 영속성 컨텍스트에 생명은 짦다고 생각(transaction 실행 사이에만 살아있음)
    - 조회하고자 하는 앤티티가 1차캐시에 없으면 디비에서 가져온후 영속 상태로 만든다
  - 동일성 보장
    - 영속 상태에 있는 앤티티는 언제 불러와도 같음을 보장한다(같은 트랜잭션 안에서만)
  - 트랜잭션을 지원하는 쓰기 지연
    - 트랜잭션이 끝나기 전까지는 같은 트랜잭션에서 발생하는 쿼리들이 실행되지 않는다
    - 해당 쿼리문은 쓰기지연 저장소에 저장된다.
    - 커낵션을 구하는 비용을 절감할 수 있어 장점이라고 생각한다.
    - 하지만 무조건 다 쓰기지연이 되지는 않는다....
  - 변경 감지
    - 엔티티매니저는 최초 영속 상태를 만들때 앤티티의 최초 스냅샷을 만들고 저장한다
    - 앤티티와 스냅샷을 비교 후 다르다면 쓰기지연 저장소에 update쿼리를 저장한다
    - 영속 상태의 엔티티에만 적용된다.
  - 지연로딩

### 엔티티의 생명주기

#### 비영속

- 영속성 컨텍스트와 관련 없는 상태

#### 영속

- 영속성 컨텍스트에 저장된 상태

#### 준영속

- 영속상태에서 분리된 상태
- 영속 상태인 엔티티가 들어있는 영속성 컨텍스트를 초기화 해도 준영속 상태
- 준영속 상태가 되면 쓰기지연 저장소 , 1차캐시에서 제거됨
- 즉 영속성 컨텍스트가 제공하는 어떤 기능도 활용 불가
- 준영속성 만드는 방법 (detach , em.clear , em.close)
- 준영속 상태를 다시 영속 상태를 만드는 방범은 merge라는 메소드를 호출하면 된다
  - merge는 비영속도 영속으로 만들수있다

#### 삭제

- 삭제된 상태

### Flush

- 영속성 컨테스트의 변경 내용을 데이터 베이스에 반영된다.
- Em.flush강제 호출 , 트랜잭션 커밋시 자동 호출 , jpql사용시(jpql쿼리를 사용하면 무조권 쿼리 발생)



